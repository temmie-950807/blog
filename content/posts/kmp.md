+++
date = '2025-08-03T21:40:44+08:00'
draft = false
title = 'KMP 演算法'
tag = ["string"]
+++

<!-- {{< katex >}} -->

> [!INFO] 先備知識與說明
> - \(a+b\) 代表字串 \(a\) 和字串 \(b\) 的相接
> - 所有字串表示都是 1-based
> - \(s[l \ldots r]\) 代表 \(s\) 的第 \(l\) 個字元到第 \(r\) 個字元形成的子字串

KMP（Knuth–Morris–Pratt algorithm）為一個字串匹配演算法，本文的目標為實現一個演算法，可以找到文本 \(S\) 中，所有模式 \(T\) 所在的位置，並且有時間複雜度 \(O(|S|+|T|)\)。
## 定義

### 共同前後綴

對於一個字串 \(S\)，我們說他有長度為 \(k\) 的共同前後綴，意指 \(S\) 滿足 \(S[1\ldots k] = S [|S|-k+1 \ldots |S|]\)。

定義一定有長度為 \(0\) 的共同前後綴，一定沒有長度為 \(|S|\) 的共同前後綴。

舉例來說，\(S = BABCBAB\)，則它有長度為 \(0, 1, 3\) 的共同前後綴：

![](kmp/kmp1.png)
### 最長共同前後綴

最大的 \(k\) 使得 \(S\) 有長度為 \(k\) 的共同前後綴。

同樣以 \(S = BABCBAB\) 舉例，它的最長共同前後綴即為 \(3\)。
### \(\pi\) 函數

對於字串 \(S\)，定義函數 \(\pi(i)\) 為它長度為 \(i\) 的前綴的最長共同前後綴。

\(S = BABCBABA\) 舉例，它所有的 \(\pi(i)\) 如下圖：

![](kmp/kmp2.png)

> [!TIP] \(\pi\) 函數的性質
> \(\pi\) 函數有個特別的性質，\(S\) 的所有共同前後綴可以由 \(\pi(S), \pi(\pi(S)), \pi(\pi(\pi(S))) \ldots\) 求得：
> 
> ![](kmp/kmp3.png)
> 
> 感性地理解，透過 \(\pi(7)\) 可知 \(BABCBAB\) 的前三個字元與後三個字元相同。但再由 \(\pi(3)\) 可知 \(BAB\) 的前一個字與後一個字相同，因此我們就可知 \(BABCBAB\) 的前一個字元與後一個字元相同，並持續下去。
> 
> 這個概念很重要～請你透過上述的方式找到 \(ABABABA\) 的所有共同前後綴。

### \(\pi\) 陣列

\(S\) 的 \(\pi\) 陣列即為 \([\pi(1), \pi(2), \ldots, \pi(|S|)]\)。

## 演算法
### 計算 \(\pi\) 陣列

我們要先計算 \(S\) 的 \(\pi\) 陣列，由 \(\pi(1)\) 求到 \(\pi(|S|)\)。

![](kmp/kmp4.png)

若我們要求得 \(\pi(i)\)，則要從 \(S[1\ldots i-1]\) 所有的共同前後綴轉移而來。如下圖，我們想要求得 \(\pi(8)\)，則需要考慮 \(S[1 \ldots 7]\) 所有的共同前後綴：

\(S[1 \ldots 7]\) 有三個共同前後綴，分別為長度為 \(3, 1, 0\)（以下由紅色方形表示）。不難發現左右兩邊紅色的部分實際上可以從它們的右邊繼續匹配（以下由橘色方形表示），若兩個橘色方形的值相同，就代表我們成功地找到 \(S[1 \ldots 8]\) 的最長前後綴。

![](kmp/kmp5.png)

若匹配成功，顯然地就有轉移來源 \(\pi\) 的值加一。以上圖來說，使用 \(S[1 \ldots 7]\) 長度為 \(3\) 的共同前後綴轉移時，\(S[4] \neq S[8]\)，因此無法從這裡轉移。使用 \(S[1 \ldots 7]\) 長度為 \(1\) 的共同前後綴轉移時，有 \(S[2] = S[8]\)，因此有 \(\pi(8) = 1(紅色長度的部分) + 1(橘色部分的長度) = 2\)。

我們另外舉一個匹配失敗的例子：

![](kmp/kmp6.png)

在這個例子中每次的匹配都不相等，因此是匹配失敗，再這樣的情況下我們就可知 \(\pi(4) = 0\)。

將以上求得 \(\pi(i)\) 的演算法透過正式的語言表達，即為：

定義 \(\pi(1) = 0\)。令 \(p = \pi(i-1)\)，若 \(S[p+1] = S[i]\)，則 \(\pi(i) = p+1\)，否則若 \(p=0\)，則結束，否則令 \(p = \pi(p)\)。

### 匹配字串
最後，到了我們的重頭戲：將 \(S\) 與 \(T\) 匹配。我們令 \(P = T + '\#' + S\)，其中 \('\#'\) 為一個在 \(S\) 跟 \(T\) 都沒有出現過的字元。

那麼對 \(P\) 計算所有 \(\pi\) 的值，若位於 \(S\) 的部分的 \(\pi\) 值為 \(|T|\)，則代表匹配成功，其原因即為 \(\pi\) 函數的定義：

![](kmp/kmp7.png)
## 實作

將上述的介紹寫成程式碼：
```cpp
// 傳入 '#'+s（也就是一個 1-based）的字串
// 回傳一個 1-based 的 pi 陣列
vector<int> get_pi(string s){
	int n = s.size();
    vector<int> pi(n, 0);

	for (int i=2 ; i<n ; i++){ // 注意 i 是從 2 開始
	    int p = pi[i-1];
	    while (1){
		    // 匹配成功
		    if (s[p+1]==s[i]){
			    pi[i] = p+1;
			    break;
		    }

			// 匹配失敗
		    if (p==0){
			    pi[i] = 0;
			    break;
		    }else{
			    p = pi[p];
		    }
	    }
	}

	return pi;
}
```

OI wiki 給出了一個更加簡短的實作方法：
```cpp
vector<int> prefix_function(string s) {
  int n = (int)s.length();
  vector<int> pi(n);
  for (int i = 1; i < n; i++) {
    int j = pi[i - 1];
    while (j > 0 && s[i] != s[j]) j = pi[j - 1];
    if (s[i] == s[j]) j++;
    pi[i] = j;
  }
  return pi;
}
```

## 時間複雜度
計算 \(S\) 的 \(\pi\) 陣列的時間複雜度是基於均攤的。

計算 \(\pi(i)\) 進入匹配成功時，會讓勢能增加 \(1\)（\(p+1\) 的部分）。每次進入匹配失敗時，都會讓勢能減少 \(p-\pi(p)\)。

注意到勢能至多為 \(|S|\)，並且不可能小於 \(0\)，因此時間複雜度是 \(O(|S|)\)。

## 例題

### 一、[String Functions](https://cses.fi/problemset/task/2107/)

裸題，同上述實作方法。

### 二、計算所有前綴出現次數（一）

題目：給定一個 \(S\)，分別求 \(S\) 每一個前綴在 \(S\) 裡的出現次數。

> [!TIP] \(\pi\) 函數的性質（樹狀結構）
> 前文提到 \(\pi\) 函數的性質，可以更形象化地畫成一顆樹。對於節點 \(i\) 指向 \(\pi(i)\)：
> 
> ![](kmp/kmp8.png)
> 
> \(S\) 的共同前後綴可以由 \(\pi(S), \pi(\pi(S)), \pi(\pi(\pi(S))) \ldots\) 求得
> 
> 這句話本質上就是從一個節點沿著邊走到根。
> 
> 我們常用這個樹狀結構做 DP 來處理各項問題。

對於每個長度為 \(j\) 的前綴，它在 \(S\) 每個出現的位置都會對應到一些右端點。

令 \(ans_{j} = \sum_{i=1}^{n} S[1 \ldots i]\) 有長度為 i 的共同前後綴。透過樹 DP，即有：\(dp[i] = 1 + \sum_{c \in child(i)} dp[c]\)。

## 參考資料
- [OI wiki](https://oi-wiki.org/string/kmp/#%E5%9C%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%AD%90%E4%B8%B2knuthmorrispratt-%E7%AE%97%E6%B3%95)