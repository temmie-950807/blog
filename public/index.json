
[{"content":"","date":"3 August 2025","externalUrl":null,"permalink":"/","section":"CP blog","summary":"","title":"CP blog","type":"page"},{"content":" KMP 演算法 # 先備知識與說明\n\\(a+b\\) 代表字串 \\(a\\) 和字串 \\(b\\) 的相接 所有字串表示都是 1-based \\(s[l \\ldots r]\\) 代表 \\(s\\) 的第 \\(l\\) 個字元到第 \\(r\\) 個字元形成的子字串 KMP（Knuth–Morris–Pratt algorithm）為一個字串匹配演算法，本文的目標為實現一個演算法，可以找到文本 \\(S\\) 中，所有模式 \\(T\\) 所在的位置，並且有時間複雜度 \\(O(|S|+|T|)\\)。\n定義 # 共同前後綴 # 對於一個字串 \\(S\\)，我們說他有長度為 \\(k\\) 的共同前後綴，意指 \\(S\\) 滿足 \\(S[1\\ldots k] = S [|S|-k+1 \\ldots |S|]\\)。\n定義一定有長度為 \\(0\\) 的共同前後綴，一定沒有長度為 \\(|S|\\) 的共同前後綴。\n舉例來說，\\(S = BABCBAB\\)，則它有長度為 \\(0, 1, 3\\) 的共同前後綴：\n![[Pasted image 20250721211414.png]]\n最長共同前後綴 # 最大的 \\(k\\) 使得 \\(S\\) 有長度為 \\(k\\) 的共同前後綴。\n同樣以 \\(S = BABCBAB\\) 舉例，它的最長共同前後綴即為 \\(3\\)。\n\\(\\pi\\) 函數 # 對於字串 \\(S\\)，定義函數 \\(\\pi(i)\\) 為它長度為 \\(i\\) 的前綴的最長共同前後綴。\n\\(S = BABCBABA\\) 舉例，它所有的 pi(i) 如下圖：\n![[Pasted image 20250721211318.png]]\ntitle: \\(\\pi\\) 函數的性質\n其中 \\(\\pi\\) 函數有個特別的性質，\\(S\\) 的所有共同前後綴可以由 \\(\\pi(S), \\pi(\\pi(S)), \\pi(\\pi(\\pi(S))) \\ldots\\) 求得：\n感性地理解，透過 \\(\\pi(7)\\) 可知 \\(BABCBAB\\) 的前三個字元與後三個字元相同。但再由 \\(\\pi(3)\\) 可知 \\(BAB\\) 的前一個字與後一個字相同，因此我們就可知 \\(BABCBAB\\) 的前一個字元與後一個字元相同，並持續下去。\n這個概念很重要～請你透過上述的方式找到 \\(ABABABA\\) 的所有共同前後綴。\n\\(\\pi\\) 陣列 # \\(S\\) 的 \\(\\pi\\) 陣列即為 \\([\\pi(1), \\pi(2), \\ldots, \\pi(|S|)]\\)。\n演算法 # 計算 \\(\\pi\\) 陣列 # 我們要先計算 \\(S\\) 的 \\(\\pi\\) 陣列，由 \\(\\pi(1)\\) 求到 \\(\\pi(|S|)\\)。\n![[Pasted image 20250721211544.png]]\n若我們要求得 \\(\\pi(i)\\)，則要從 \\(S[1\\ldots i-1]\\) 所有的共同前後綴轉移而來。如下圖，我們想要求得 \\(\\pi(8)\\)，則需要考慮 \\(S[1 \\ldots 7]\\) 所有的共同前後綴：\n\\(S[1 \\ldots 7]\\) 有三個共同前後綴，分別為長度為 \\(3, 1, 0\\)（以下由紅色方形表示）。不難發現左右兩邊紅色的部分實際上可以從它們的右邊繼續匹配（以下由橘色方形表示），若兩個橘色方形的值相同，就代表我們成功地找到 \\(S[1 \\ldots 8]\\) 的最長前後綴。\n![[Pasted image 20250721212016.png]]\n若匹配成功，顯然地就有轉移來源 \\(\\pi\\) 的值加一。以上圖來說，使用 \\(S[1 \\ldots 7]\\) 長度為 \\(3\\) 的共同前後綴轉移時，\\(S[4] \\neq S[8]\\)，因此無法從這裡轉移。使用 \\(S[1 \\ldots 7]\\) 長度為 \\(1\\) 的共同前後綴轉移時，有 \\(S[2] = S[8]\\)，因此有 \\(\\pi(8) = 1(紅色長度的部分) + 1(橘色部分的長度) = 2\\)。\n我們另外舉一個匹配失敗的例子：\n![[Pasted image 20250721212802.png]]\n在這個例子中每次的匹配都不相等，因此是匹配失敗，再這樣的情況下我們就可知 \\(\\pi(4) = 0\\)。\n將以上求得 \\(\\pi(i)\\) 的演算法透過正式的語言表達，即為：\n定義 \\(\\pi(1) = 0\\)。令 \\(p = \\pi(i-1)\\)，若 \\(S[p+1] = S[i]\\)，則 \\(\\pi(i) = p+1\\)，否則若 \\(p=0\\)，則結束，否則令 \\(p = \\pi(p)\\)。\n匹配字串 # 最後，到了我們的重頭戲：將 \\(S\\) 與 \\(T\\) 匹配。我們令 \\(P = T + '\\#' + S\\)，其中 \\('\\#'\\) 為一個在 \\(S\\) 跟 \\(T\\) 都沒有出現過。\n那麼對 \\(P\\) 計算所有 \\(\\pi\\) 的值，若位於 \\(S\\) 的部分的 \\(\\pi\\) 值為 \\(|T|\\)，則代表匹配成功，其原因即為 \\(\\pi\\) 函數的定義：\n![[Pasted image 20250721215838.png]]\n實作 # 將上述的介紹寫成程式碼：\n// 傳入 \u0026#39;#\u0026#39;+s（也就是一個 1-based）的字串 // 回傳一個 1-based 的 pi 陣列 vector\u0026lt;int\u0026gt; get_pi(string s){ int n = s.size(); vector\u0026lt;int\u0026gt; pi(n, 0); for (int i=2 ; i\u0026lt;n ; i++){ // 注意 i 是從 2 開始 int p = pi[i-1]; while (1){ // 匹配成功 if (s[p+1]==s[i]){ pi[i] = p+1; break; } // 匹配失敗 if (p==0){ pi[i] = 0; break; }else{ p = pi[p]; } } } return pi; } OI wiki 給出了一個更加簡短的實作方法：\nvector\u0026lt;int\u0026gt; prefix_function(string s) { int n = (int)s.length(); vector\u0026lt;int\u0026gt; pi(n); for (int i = 1; i \u0026lt; n; i++) { int j = pi[i - 1]; while (j \u0026gt; 0 \u0026amp;\u0026amp; s[i] != s[j]) j = pi[j - 1]; if (s[i] == s[j]) j++; pi[i] = j; } return pi; } 時間複雜度 # 計算 \\(S\\) 的 \\(\\pi\\) 陣列的時間複雜度是基於均攤的。\n計算 \\(\\pi(i)\\) 進入匹配成功時，會讓勢能增加 \\(1\\)（\\(p+1\\) 的部分）。每次進入匹配失敗時，都會讓勢能減少 \\(p-\\pi(p)\\)。\n注意到勢能至多為 \\(|S|\\)，並且不可能小於 \\(0\\)，因此時間複雜度是 \\(O(|S|)\\)。\n例題 # 一、String Functions # 裸題，同上述實作方法。\n二、計算所有前綴出現次數（一） # 題目：給定一個 \\(S\\)，分別求 \\(S\\) 每一個前綴在 \\(S\\) 裡的出現次數。\ntitle: \\(\\pi\\) 函數的性質（樹狀結構） 前文提到 \\(\\pi\\) 函數的性質，可以更形象化地畫成一顆樹。對於節點 \\(i\\) 指向 \\(\\pi(i)\\)： ![[Pasted image 20250721223435.png]] \u0026gt; \\(S\\) 的共同前後綴可以由 \\(\\pi(S), \\pi(\\pi(S)), \\pi(\\pi(\\pi(S))) \\ldots\\) 求得 這句話本質上就是從一個節點沿著邊走到根。 我們常用這個樹狀結構做 DP 來處理各項問題。 對於每個長度為 \\(j\\) 的前綴，它在 \\(S\\) 每個出現的位置都會對應到一些右端點。\n令 \\(ans_{j} = \\sum_{i=1}^{n} S[1 \\ldots i]\\) 有長度為 i 的共同前後綴。透過樹 DP，即有：\\(dp[i] = 1 + \\sum_{c \\in child(i)} dp[c]\\)。\n參考資料 # OI wiki ","date":"3 August 2025","externalUrl":null,"permalink":"/posts/kmp/","section":"Posts","summary":"","title":"KMP 演算法","type":"posts"},{"content":"","date":"3 August 2025","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]